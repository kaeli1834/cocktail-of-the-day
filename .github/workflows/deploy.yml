name: ğŸš€ CI/CD - Cocktail of the Day

on:
  push:
    branches: ["main"]
    paths-ignore:
      - "README.md"
      - "docs/**"
      - "*.md"
  workflow_dispatch:
    inputs:
      environment:
        description: "Environment to deploy to"
        required: true
        default: "production"
        type: choice
        options:
          - production
          - staging
      skip_tests:
        description: "Skip tests"
        required: false
        default: false
        type: boolean

# Ã‰vite les dÃ©ploiements concurrents
concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}-${{ inputs.environment || 'production' }}
  cancel-in-progress: false

env:
  REGISTRY: ghcr.io
  IMAGE_API: ghcr.io/${{ github.repository }}/cocktail-api
  IMAGE_FRONT: ghcr.io/${{ github.repository }}/cocktail-front

jobs:
  test:
    name: ğŸ§ª Run Tests
    runs-on: ubuntu-latest
    if: ${{ !inputs.skip_tests }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "20"
          cache: "npm"
          cache-dependency-path: |
            cocktail-api/package-lock.json
            cocktail-front/package-lock.json

      - name: Test API
        run: |
          cd cocktail-api
          npm ci
          npm run test || echo "No tests configured for API"

      - name: Test Frontend
        run: |
          cd cocktail-front
          npm ci
          npm run test || echo "No tests configured for Frontend"

  build-and-push:
    name: ğŸ—ï¸ Build & Push Images
    runs-on: ubuntu-latest
    needs: [test]
    if: always() && (needs.test.result == 'success' || needs.test.result == 'skipped')
    outputs:
      api-image: ${{ steps.meta-api.outputs.tags }}
      front-image: ${{ steps.meta-front.outputs.tags }}
      api-digest: ${{ steps.build-api.outputs.digest }}
      front-digest: ${{ steps.build-front.outputs.digest }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to GHCR
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      # ---------- API Metadata ----------
      - name: Extract API metadata
        id: meta-api
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.IMAGE_API }}
          tags: |
            type=ref,event=branch
            type=ref,event=pr
            type=sha,prefix={{branch}}-
            type=raw,value=latest,enable={{is_default_branch}}
          labels: |
            org.opencontainers.image.title=Cocktail API
            org.opencontainers.image.description=Backend API for Cocktail of the Day
            org.opencontainers.image.vendor=CocktailApp

      # ---------- API Build ----------
      - name: Build & Push API image
        id: build-api
        uses: docker/build-push-action@v6
        with:
          context: ./cocktail-api
          platforms: linux/amd64,linux/arm64
          push: true
          tags: ${{ steps.meta-api.outputs.tags }}
          labels: ${{ steps.meta-api.outputs.labels }}
          cache-from: type=gha,scope=api
          cache-to: type=gha,mode=max,scope=api
          build-args: |
            NODE_ENV=production

      # ---------- Frontend Metadata ----------
      - name: Extract Frontend metadata
        id: meta-front
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.IMAGE_FRONT }}
          tags: |
            type=ref,event=branch
            type=ref,event=pr
            type=sha,prefix={{branch}}-
            type=raw,value=latest,enable={{is_default_branch}}
          labels: |
            org.opencontainers.image.title=Cocktail Frontend
            org.opencontainers.image.description=React frontend for Cocktail of the Day
            org.opencontainers.image.vendor=CocktailApp

      # ---------- Frontend Build ----------
      - name: Build & Push Frontend image
        id: build-front
        uses: docker/build-push-action@v6
        with:
          context: ./cocktail-front
          file: ./cocktail-front/Dockerfile
          platforms: linux/amd64,linux/arm64
          push: true
          tags: ${{ steps.meta-front.outputs.tags }}
          labels: ${{ steps.meta-front.outputs.labels }}
          cache-from: type=gha,scope=frontend
          cache-to: type=gha,mode=max,scope=frontend
          build-args: |
            VITE_API_URL=http://localhost:3000

  deploy:
    name: ğŸš€ Deploy
    needs: build-and-push
    runs-on: ubuntu-latest
    environment: ${{ inputs.environment || 'production' }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Create deployment status
        id: deployment
        uses: chrnorm/deployment-action@v2
        with:
          token: ${{ github.token }}
          environment: ${{ inputs.environment || 'production' }}
          initial-status: "in_progress"

      - name: Deploy to server
        id: deploy
        uses: appleboy/ssh-action@v1.2.0
        with:
          host: ${{ secrets.SSH_HOST }}
          username: ${{ secrets.SSH_USER }}
          key: ${{ secrets.SSH_KEY }}
          port: ${{ secrets.SSH_PORT || 22 }}
          script_stop: true
          command_timeout: 10m
          script: |
            set -euo pipefail
            echo "ğŸš€ Starting deployment..."

            # Navigate to deployment directory
            cd "${{ secrets.SSH_PATH }}"
            echo "ğŸ“ Working directory: $(pwd)"

            # Login to GHCR (uncomment if using private images)
            if [[ -n "${GHCR_TOKEN:-}" ]]; then
              echo "ğŸ” Logging in to GHCR..."
              echo "${GHCR_TOKEN}" | docker login ghcr.io -u "${GHCR_USERNAME}" --password-stdin
            fi

            # Verify docker compose
            echo "ğŸ³ Docker Compose version:"
            docker compose version

            # Create backup of current state
            echo "ğŸ’¾ Creating backup..."
            docker compose config > docker-compose.backup.yml

            # Health check before deployment
            echo "ğŸ¥ Running pre-deployment health check..."
            if docker compose ps --services --filter "status=running" | grep -q .; then
              echo "âœ… Services are running"
            else
              echo "âš ï¸  No services currently running"
            fi

            # Pull latest images
            echo "ğŸ“¦ Pulling latest images..."
            docker compose pull

            # Deploy with zero-downtime strategy
            echo "ğŸ”„ Deploying services..."
            docker compose up -d --remove-orphans

            # Wait for services to be ready
            echo "â³ Waiting for services to be ready..."
            sleep 30

            # Health check after deployment
            echo "ğŸ¥ Running post-deployment health check..."
            max_retries=10
            retry_count=0

            while [ $retry_count -lt $max_retries ]; do
              if curl -f http://localhost:3000/health > /dev/null 2>&1; then
                echo "âœ… API is healthy"
                break
              else
                echo "â³ API not ready yet, retrying... ($((retry_count + 1))/$max_retries)"
                sleep 10
                retry_count=$((retry_count + 1))
              fi
            done

            if [ $retry_count -eq $max_retries ]; then
              echo "âŒ API health check failed after $max_retries attempts"
              exit 1
            fi

            # Check frontend
            if curl -f http://localhost:8080 > /dev/null 2>&1; then
              echo "âœ… Frontend is accessible"
            else
              echo "âš ï¸  Frontend health check failed"
            fi

            # Cleanup old images
            echo "ğŸ§¹ Cleaning up old images..."
            docker image prune -f

            # Show running containers
            echo "ğŸ“‹ Running containers:"
            docker compose ps

            echo "ğŸ‰ Deployment completed successfully!"
        env:
          GHCR_USERNAME: ${{ secrets.GHCR_USERNAME }}
          GHCR_TOKEN: ${{ secrets.GHCR_TOKEN }}
          DEPLOY_PATH: ${{ secrets.DEPLOY_PATH }}

      - name: Update deployment status (success)
        if: success()
        uses: chrnorm/deployment-action@v2
        with:
          token: ${{ github.token }}
          environment: ${{ inputs.environment || 'production' }}
          state: "success"
          deployment-id: ${{ steps.deployment.outputs.deployment_id }}

      - name: Update deployment status (failure)
        if: failure()
        uses: chrnorm/deployment-action@v2
        with:
          token: ${{ github.token }}
          environment: ${{ inputs.environment || 'production' }}
          state: "failure"
          deployment-id: ${{ steps.deployment.outputs.deployment_id }}

  notify:
    name: ğŸ“¢ Notify
    runs-on: ubuntu-latest
    needs: [deploy]
    if: always()
    steps:
      - name: Notify success
        if: needs.deploy.result == 'success'
        run: |
          echo "âœ… Deployment successful!"
          echo "ğŸŒ Application should be available at your configured URL"

      - name: Notify failure
        if: needs.deploy.result == 'failure'
        run: |
          echo "âŒ Deployment failed!"
          echo "Please check the logs and verify your server configuration"
