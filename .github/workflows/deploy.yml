name: üöÄ CI/CD - Cocktail of the Day

on:
  push:
    branches: ["main"]
    paths-ignore:
      - "README.md"
      - "docs/**"
      - "*.md"
  workflow_dispatch:
    inputs:
      environment:
        description: "Environment to deploy to"
        required: true
        default: "production"
        type: choice
        options:
          - production
          - staging
      skip_tests:
        description: "Skip tests"
        required: false
        default: false
        type: boolean

# √âvite les d√©ploiements concurrents
concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}-${{ inputs.environment || 'production' }}
  cancel-in-progress: false

permissions:
  contents: read
  packages: write
  id-token: write
  security-events: write
  deployments: write

env:
  REGISTRY: ghcr.io
  IMAGE_API: ghcr.io/${{ github.repository }}/cocktail-api
  IMAGE_FRONT: ghcr.io/${{ github.repository }}/cocktail-front

jobs:
  test:
    name: üß™ Run Tests
    runs-on: ubuntu-latest
    if: ${{ !inputs.skip_tests }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "20"
          cache: "npm"
          cache-dependency-path: |
            cocktail-api/package-lock.json
            cocktail-front/package-lock.json

      - name: Test API
        run: |
          cd cocktail-api
          npm ci
          npm run test || echo "No tests configured for API"

      - name: Test Frontend
        run: |
          cd cocktail-front
          npm ci
          npm run test || echo "No tests configured for Frontend"

  security-scan:
    name: üîí Security Scan
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Run Trivy vulnerability scanner
        uses: aquasecurity/trivy-action@master
        with:
          scan-type: "fs"
          scan-ref: "."
          format: "sarif"
          output: "trivy-results.sarif"
          severity: "CRITICAL,HIGH"

      - name: Upload Trivy scan results to GitHub Security tab
        uses: github/codeql-action/upload-sarif@v3
        if: always()
        with:
          sarif_file: "trivy-results.sarif"

  build-and-push:
    name: üèóÔ∏è Build & Push Images
    runs-on: ubuntu-latest
    needs: [test, security-scan]
    if: always() && (needs.test.result == 'success' || needs.test.result == 'skipped') && needs.security-scan.result == 'success'
    outputs:
      api-image: ${{ steps.meta-api.outputs.tags }}
      front-image: ${{ steps.meta-front.outputs.tags }}
      api-digest: ${{ steps.build-api.outputs.digest }}
      front-digest: ${{ steps.build-front.outputs.digest }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to GHCR
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      # ---------- API Metadata ----------
      - name: Extract API metadata
        id: meta-api
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.IMAGE_API }}
          tags: |
            type=ref,event=branch
            type=ref,event=pr
            type=sha,prefix={{branch}}-
            type=raw,value=latest,enable={{is_default_branch}}
          labels: |
            org.opencontainers.image.title=Cocktail API
            org.opencontainers.image.description=Backend API for Cocktail of the Day
            org.opencontainers.image.vendor=CocktailApp

      # ---------- API Build ----------
      - name: Build & Push API image
        id: build-api
        uses: docker/build-push-action@v6
        with:
          context: ./cocktail-api
          platforms: linux/amd64,linux/arm64
          push: true
          tags: ${{ steps.meta-api.outputs.tags }}
          labels: ${{ steps.meta-api.outputs.labels }}
          cache-from: type=gha,scope=api
          cache-to: type=gha,mode=max,scope=api
          build-args: |
            NODE_ENV=production

      # ---------- Frontend Metadata ----------
      - name: Extract Frontend metadata
        id: meta-front
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.IMAGE_FRONT }}
          tags: |
            type=ref,event=branch
            type=ref,event=pr
            type=sha,prefix={{branch}}-
            type=raw,value=latest,enable={{is_default_branch}}
          labels: |
            org.opencontainers.image.title=Cocktail Frontend
            org.opencontainers.image.description=React frontend for Cocktail of the Day
            org.opencontainers.image.vendor=CocktailApp

      # ---------- Frontend Build ----------
      - name: Build & Push Frontend image
        id: build-front
        uses: docker/build-push-action@v6
        with:
          context: ./cocktail-front
          file: ./cocktail-front/Dockerfile
          platforms: linux/amd64,linux/arm64
          push: true
          tags: ${{ steps.meta-front.outputs.tags }}
          labels: ${{ steps.meta-front.outputs.labels }}
          cache-from: type=gha,scope=frontend
          cache-to: type=gha,mode=max,scope=frontend
          build-args: |
            VITE_API_URL=http://localhost:3000

  deploy:
    name: üöÄ Deploy
    needs: build-and-push
    runs-on: ubuntu-latest
    environment: ${{ inputs.environment || 'production' }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Create deployment status
        id: deployment
        uses: chrnorm/deployment-action@v2
        with:
          token: ${{ github.token }}
          environment: ${{ inputs.environment || 'production' }}
          initial-status: "in_progress"

      - name: Deploy to server
        id: deploy
        uses: appleboy/ssh-action@v1.2.0
        with:
          host: ${{ secrets.SSH_HOST }}
          username: ${{ secrets.SSH_USER }}
          key: ${{ secrets.SSH_KEY }}
          port: ${{ secrets.SSH_PORT || 22 }}
          script_stop: true
          command_timeout: 10m
          script: |
            set -euo pipefail
            echo "Starting deployment..."

            # Navigate to deployment directory
            cd "${{ secrets.SSH_PATH }}"
            echo "Working directory: $(pwd)"

            # Login to GHCR
            docker login ghcr.io -u ${{ github.actor }} -p ${{ secrets.GITHUB_TOKEN }}


            # Verify docker compose
            echo "Docker Compose version:"
            docker compose version

            # Create backup of current state
            echo "Creating backup..."
            docker compose -f compose.cocktail.prod.yml config > docker-compose.backup.yml

            # Health check before deployment
            echo "Running pre-deployment health check..."
            if docker compose -f compose.cocktail.prod.yml ps --services --filter "status=running" 2>/dev/null | grep -q . || true; then
              echo "Services are running"
            else
              echo "No services currently running"
            fi

            # Pull latest images
            echo "Pulling latest images..."
            docker compose -f compose.cocktail.prod.yml pull

            # Ensure compose file uses only registry images, not local build contexts

            # Deploy with zero-downtime strategy
            echo "Deploying services..."
            docker compose -f compose.cocktail.prod.yml up -d --remove-orphans

            # Wait for services to be ready
            echo "Waiting for services to be ready..."
            sleep 30

            # Health check after deployment
            echo "Running post-deployment health check..."
            max_retries=10
            retry_count=0

            while [ $retry_count -lt $max_retries ]; do
              if curl -f http://localhost:3000/api/health > /dev/null 2>&1; then
                echo "API is healthy"
                break
              else
                echo "API not ready yet, retrying... ($((retry_count + 1))/$max_retries)"
                sleep 10
                retry_count=$((retry_count + 1))
              fi
            done

            if [ $retry_count -eq $max_retries ]; then
              echo "API health check failed after $max_retries attempts"
              exit 1
            fi

            # Check frontend
            if curl -f http://localhost:8080 > /dev/null 2>&1; then
              echo "Frontend is accessible"
            else
              echo "Frontend health check failed"
            fi

            # Cleanup old images
            echo "Cleaning up old images..."
            docker image prune -f

            # Show running containers
            echo "Running containers:"
            docker compose ps

            echo "Deployment completed successfully!"
        env:
          GHCR_USERNAME: ${{ secrets.GHCR_USERNAME }}
          GHCR_TOKEN: ${{ secrets.GHCR_TOKEN }}
          DEPLOY_PATH: ${{ secrets.DEPLOY_PATH }}

      - name: Update deployment status (success)
        if: success()
        uses: chrnorm/deployment-action@v2
        with:
          token: ${{ github.token }}
          environment: ${{ inputs.environment || 'production' }}
          state: "success"
          deployment-id: ${{ steps.deployment.outputs.deployment_id }}

      - name: Update deployment status (failure)
        if: failure()
        uses: chrnorm/deployment-action@v2
        with:
          token: ${{ github.token }}
          environment: ${{ inputs.environment || 'production' }}
          state: "failure"
          deployment-id: ${{ steps.deployment.outputs.deployment_id }}

  notify:
    name: üì¢ Notify
    runs-on: ubuntu-latest
    needs: [deploy]
    if: always()
    steps:
      - name: Notify success
        if: needs.deploy.result == 'success'
        run: |
          echo "‚úÖ Deployment successful!"
          echo "üåê Application should be available at your configured URL"

      - name: Notify failure
        if: needs.deploy.result == 'failure'
        run: |
          echo "‚ùå Deployment failed!"
          echo "Please check the logs and verify your server configuration"
